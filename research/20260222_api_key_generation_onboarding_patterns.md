# API Key Generation, Management, and Onboarding Patterns

**Research Date:** 2026-02-22
**Research Mode:** Deep Research
**Topic:** How developer tools and API-first products handle API key generation, management, and onboarding

---

## Research Summary

There is no single dominant pattern for API key generation across developer tools — the approach varies significantly by deployment model (cloud SaaS vs. self-hosted), use case, and the tool's philosophy on DX. Cloud-native platforms (Supabase, Resend, Clerk) auto-generate keys immediately on project creation and surface them via dashboard. Self-hosted tools (Strapi, Directus, Inngest, Ghost) predominantly require manual key creation through a UI, CLI command, or environment variable — though several use `npx create-*` scaffolding to auto-generate secrets during project init. The state of the art for self-hosted open-source tools is: **auto-generate all internal secrets (JWT secrets, salts) during `npx create-*` setup, but require the user to explicitly copy and set the externally-facing API key (Bearer token) in their env**, with a clear `setup` script or interactive prompt to make that frictionless.

---

## Key Findings

### 1. Cloud SaaS: Keys Are Auto-Generated on Project Creation

Cloud platforms auto-generate keys at the moment a project exists. No manual action required.

- **Supabase**: "They are generated when your project is created and can only be changed when you rotate the JWT secret." The platform generates both `anon` (publishable) and `service_role` (secret) keys automatically. New key format: `sb_publishable_*` and `sb_secret_*`. The Vercel-Supabase integration goes further — it automatically syncs all environment variables to Vercel projects, so developers never manually copy anything.
- **Neon**: API keys are manual, not auto-generated. Users navigate to Account Settings > API Keys and click to generate a personal key. Once they have one personal key, they can create additional keys via the API. The first key is always manually created through the console.
- **Vercel**: The platform generates project-specific tokens but does not auto-generate a Bearer token for external API use on project creation. Access tokens are created manually in the dashboard. However, environment variables from connected integrations (Supabase, Neon) are synced automatically.
- **Railway**: No auto-generated per-project API key. Users create API tokens manually via their account settings. Railway focuses on infrastructure and environment variable management rather than API key provisioning.
- **Resend**: Manual. User navigates to API Keys in the left menu, clicks "Create API Key", sets permissions and domain. The key is shown once and must be copied immediately.
- **Clerk**: Manual. Navigate to Configure > Developer > API Keys. Clerk also provides UI components developers can embed in their own apps so end-users can generate API keys for their own SaaS products.

**Summary pattern**: Cloud SaaS creates the key for you (Supabase) OR surfaces a clear, frictionless 2-click flow to generate one (Resend, Clerk). The "shown only once" UX is universal — show the secret, provide a copy button, warn that it won't be shown again.

---

### 2. Self-Hosted / npm Package Patterns

#### Strapi (`npx create-strapi-app`)

Strapi is the most sophisticated example of self-hosted API key handling. The `create-strapi-app` scaffolding generates a `.env` file automatically containing:

```
APP_KEYS="<auto-generated-random-values>"
API_TOKEN_SALT=<auto-generated>
ADMIN_JWT_SECRET=<auto-generated>
TRANSFER_TOKEN_SALT=<auto-generated>
JWT_SECRET=<auto-generated>
```

**Important nuance**: Strapi generates actual random values for most secrets during `create-strapi-app`. However, earlier versions used placeholder strings like `toBeModified1,toBeModified2`. Modern Strapi uses crypto-secure generation. For production, the recommendation is to regenerate using `openssl rand -base64 16`.

Strapi's externally-facing API tokens (the Bearer tokens used by external consumers) are **separate** from these internal secrets. They are created post-setup through the Admin UI under Settings > API Tokens, or programmatically via the API.

**The Strapi pattern is a two-layer model**:

1. Internal secrets (JWT signing, salts) — auto-generated on project creation
2. External API tokens — manually created post-setup in the admin UI

#### Directus (Self-hosted)

Directus has a different approach. On first run:

1. User visits `http://localhost:8055`
2. An onboarding screen asks for admin email/password
3. After setup completes, the user navigates to Users > their user > Token field to generate a static token

Environment variables `KEY` and `SECRET` must be set before first run. These can be any random strings (Directus docs recommend `openssl rand -hex 32`). Admin credentials can be pre-set via `ADMIN_EMAIL` and `ADMIN_PASSWORD` env vars for automated deployments (CI/CD), and the recommendation is to delete them from env after first run.

**The Directus pattern**: Require env-based secrets before first run, but defer external API token creation to a post-setup UI flow.

#### Ghost CMS (Self-hosted)

Ghost does not auto-generate API keys. After installation and first login, the user navigates to:
Settings > Integrations > Add Custom Integration

Each integration automatically receives Content API and Admin API keys. The Admin API key format is `id:secret` (two parts separated by a colon). Ghost relies on the integration creation UI flow rather than setup-time generation.

#### Medusa (`npx create-medusa-app`)

`create-medusa-app` installs the backend and automatically generates a publishable API key for the storefront. This is notable — the Next.js starter integration gets its `NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY` set in environment variables automatically during the install process.

For secret/admin API keys, these are created post-setup through: Settings > Secret API Keys > Create.

**The Medusa pattern**: Auto-generate the client-facing (low-privilege) publishable key during setup. Require manual creation of the high-privilege secret key post-setup.

#### Inngest (Self-hosted)

Inngest requires manual secret generation before starting the server. The docs say explicitly:

> "create your event and signing keys using whatever format you choose"

Recommended generation: `openssl rand -hex 32`

Then pass them as flags or env vars:

```bash
inngest start --event-key <YOUR_EVENT_KEY> --signing-key <YOUR_SIGNING_KEY>
INNGEST_EVENT_KEY=<key> INNGEST_SIGNING_KEY=<key> inngest start
```

No key management UI at initial release. No interactive prompt. The user is expected to know to run openssl.

#### Umami Analytics (Self-hosted)

Umami requires `APP_SECRET` to be generated before startup:

```bash
openssl rand 30 | openssl base64 -A
```

This is added to `.env`. The application secret is used for JWT token signing — it's an internal secret, not an externally-shared API key. Umami Cloud handles API keys differently (generated via the dashboard UI).

#### Trigger.dev (Self-hosted)

Requires `TRIGGER_API_URL` and `TRIGGER_SECRET_KEY` environment variables. Keys are accessed via the dashboard's API keys page. No auto-generation during install; users retrieve keys from the dashboard after setup.

---

### 3. Zero-Config / Interactive Setup Patterns

The state of the art for `npx create-*` tooling regarding secrets:

#### NextAuth / Auth.js Pattern

This is the gold standard for "zero-friction secret setup." Auth.js provides:

```bash
npx auth secret
```

This command:

1. Generates a cryptographically secure random value using Node's `crypto` module
2. Automatically writes `AUTH_SECRET=<generated-value>` to `.env.local`
3. Requires no user input — it's fully automatic

This is the cleanest possible pattern for internal secrets. The developer runs one command and the secret is handled.

#### Better Auth CLI

Better Auth follows the same pattern with its own CLI that generates and injects secrets into the env file automatically during project initialization.

#### GetStream NPX Script Pattern

The GetStream blog documents an interactive setup pattern using:

- **yargs** — for named CLI arguments
- **readline** — for interactive prompts

The pattern:

1. Prompt user interactively for external credentials (API keys they already have from other services)
2. For secrets that can be generated locally, generate them automatically using `crypto.randomBytes()`
3. Write everything to `.env.local` programmatically

**Key insight from this pattern**: Auto-generate what you can, prompt for what you can't. Never make the user figure out how to generate their own random bytes.

#### The crypto.randomBytes Standard

The accepted standard across the Node.js ecosystem for generating secrets:

```js
// 256-bit secret, hex encoded
crypto.randomBytes(32).toString('hex');

// base64url encoded (shorter, URL-safe)
crypto.randomBytes(32).toString('base64url');

// base64 encoded
crypto.randomBytes(32).toString('base64');
```

Equivalent shell command:

```bash
openssl rand -hex 32
openssl rand -base64 32
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

---

### 4. Developer Experience Pain Points and Best Practices

#### What Developers Hate

Based on research across API integration documentation and developer experience reports:

1. **The cold-start env problem**: Having to figure out which env vars are needed before the app even starts. An app that crashes at startup with `Missing required environment variable: LOOP_API_KEY` with no guidance on how to get it is maximally frustrating.

2. **Opaque key generation**: Being told to "generate a secure random key" with no guidance on the format, length, or command to run. Different tools have different format requirements (hex, base64, base64url) — developers shouldn't have to guess.

3. **The .env.example gap**: Tools that provide `.env.example` with placeholder values like `YOUR_API_KEY_HERE` are better than nothing, but the user still has to open the file, understand what each var means, and figure out how to populate each one.

4. **Shown-more-than-once keys**: If a secret is retrievable from the dashboard forever, it means the platform is storing it unhashed. Developers have learned to distrust this.

5. **Scattered documentation**: Key setup information spread across multiple docs pages (installation guide, configuration reference, security guide) instead of a single quickstart path.

6. **Manual bootstrap dependencies**: "Create API key X before you can create API key Y" chains. Neon's pattern of requiring a console-created key to use the API to create more keys is a mild form of this.

#### What Works Well

1. **Auto-generate on project create** (Supabase, Medusa publishable key): Zero friction. The key exists as soon as the project exists.

2. **CLI secret generation** (`npx auth secret`, Auth.js): One command generates and writes the secret. Removes all guesswork.

3. **Integrate env var setup into the installer** (Strapi, Medusa): The `npx create-*` command writes a `.env` file with auto-generated values. Developer has a working file immediately.

4. **Show once, copy prominently**: Dashboard shows the key immediately on creation with a large copy button. Warning: "This will not be shown again." Clear, secure, predictable.

5. **Env var + .env.example with explanation**: A well-commented `.env.example` that explains not just the variable name but what it's for, what format it should be in, and how to generate it.

6. **Graceful startup error messages**: Instead of a raw crash, output something like:

   ```
   ERROR: LOOP_API_KEY is not set.

   To fix this, run:
     npm run setup

   Or generate a key manually:
     node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

   Then add to your .env file:
     LOOP_API_KEY=<generated-value>
   ```

7. **Time to First Call (TTFC) optimization**: The best platforms measure how long it takes from signup to first successful API call and actively optimize it. For self-hosted tools, the equivalent metric is "time from `npm install` to first successful request."

---

### 5. Environment Variable Patterns

#### The .env.example Standard

Every serious self-hosted tool ships a `.env.example` file in the repo root that is:

- Committed to git (unlike `.env` which is gitignored)
- Contains all required and optional variables with placeholder values
- Includes comments explaining purpose and format
- Sometimes includes the generation command inline as a comment

Best-in-class example (from Inngest/NextAuth style):

```bash
# JWT signing secret — generate with: openssl rand -hex 32
AUTH_SECRET=

# API base URL for this deployment
API_URL=http://localhost:5667

# Bearer token for authenticating API requests
# Generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
LOOP_API_KEY=
```

#### The Zod Validation Pattern

Zod-based environment validation (used in this repo's `env.ts`) has become the standard pattern for TypeScript projects:

1. Define schema with Zod at startup
2. Parse `process.env` against the schema
3. On failure, emit a formatted error message listing which vars are missing/invalid
4. Crash fast, loudly, helpfully

This is far better than silent undefined errors deep in request handling. The pattern is used by T3 Stack, Auth.js, and most modern TypeScript starter kits.

#### Interactive Prompt Approaches

Some tools (Strapi, Medusa) use interactive prompts during `create-*`:

- Ask for the database URL (can't be auto-generated)
- Auto-generate everything else
- Write a `.env` with both types of values

The `@clack/prompts` and `inquirer` npm packages are common choices for interactive CLI setup. Strapi v4+ uses this pattern heavily.

#### The `vercel env pull` Pattern

Vercel's approach to env var distribution is worth noting for teams:

```bash
vercel env pull .env.local
```

This pulls all env vars from Vercel's dashboard and writes them to a local `.env.local`. It's a "fetch your env" pattern rather than "generate your env." The developer authenticates to Vercel CLI, and the rest is automatic.

Equivalent pattern for self-hosted: a `setup` script that authenticates to your cloud deployment and pulls down env vars.

---

## Detailed Analysis

### The Two-Layer Model (Internal vs. External Keys)

The most important architectural distinction in API key design for self-hosted tools is the difference between:

**Layer 1: Internal secrets** (JWT signing keys, salts, app encryption keys)

- Purpose: Used internally by the application for cryptographic operations
- Who needs them: The app itself, no external consumers
- Generation: Auto-generated by the installer, stored in `.env`
- Format: Any sufficiently random bytes (hex or base64)
- Rotation: Rarely rotated; rotation invalidates all derived tokens
- Examples: `ADMIN_JWT_SECRET`, `JWT_SECRET`, `APP_KEYS`, `TOKEN_SECRET`

**Layer 2: External API keys** (Bearer tokens for external consumers)

- Purpose: Authenticate external callers (SDKs, CI scripts, other services)
- Who needs them: External callers of your API
- Generation: Should be explicitly created, not auto-generated without the user knowing
- Format: Can be anything, but a recognizable prefix (`sk_`, `pk_`, `loop_`) aids identification
- Rotation: Rotated more frequently; should be independent of internal secrets
- Examples: `LOOP_API_KEY`, Stripe's `sk_live_*`, Resend's `re_*`, Supabase's `sb_secret_*`

**The key insight**: Many tools conflate these two layers, creating confusion. Strapi, for example, auto-generates internal secrets during setup, but external API tokens are always manually created through the admin UI post-setup. This is the right separation.

### Key Format Conventions Worth Adopting

Modern API keys use structured prefixes to make them identifiable and scannable by secret detection tools (GitHub secret scanning, Doppler, etc.):

| Product        | Key Format                            |
| -------------- | ------------------------------------- |
| Stripe         | `sk_live_...`, `pk_live_...`          |
| Supabase (new) | `sb_publishable_...`, `sb_secret_...` |
| Resend         | `re_...`                              |
| Clerk          | `sk_live_...`, `pk_live_...`          |
| Unkey          | `uk_...`                              |
| Anthropic      | `sk-ant-...`                          |

A recognizable prefix means:

- GitHub can detect leaked keys automatically
- Developers can tell at a glance what a key is for
- Secret rotation tools can scope their searches

For Loop, `loop_` or `lp_` as a prefix for externally-shared API keys would be appropriate.

### The Unkey Pattern for Key Management

Unkey (open source, MIT) is the dedicated open-source API key management platform. It provides:

- One-way hashed key storage (never stores raw keys)
- Key expiration, rate limiting, usage quotas
- Granular permission and role-based access
- SDKs for TypeScript, Python, Go, etc.
- Self-hostable

For a product like Loop that starts with a single `LOOP_API_KEY`, Unkey would be overkill. But as Loop grows to support multi-tenant or multi-key scenarios, Unkey's pattern (or Unkey itself) becomes relevant.

### Recommendation Matrix for Self-Hosted Open-Source Tools

| Scenario                                       | Recommended Pattern                                                                               |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| Internal JWT secrets                           | Auto-generate in `npx create-*` or `npm run setup` using `crypto.randomBytes(32).toString('hex')` |
| External Bearer token (single key per install) | Require user to set it, but provide `npm run setup` that generates and writes it to `.env`        |
| External Bearer token (multi-key)              | Build a key management UI or use Unkey                                                            |
| Env var validation                             | Zod schema in `env.ts`, crash fast with helpful error                                             |
| `.env.example`                                 | Commit to repo, comment every var with format and generation command                              |
| Dashboard key display                          | Show once, copy button, warn it won't be shown again                                              |
| Key format                                     | Use a recognizable prefix (`loop_`, `lp_`) for external keys                                      |

---

## Specific Recommendations for Loop

Given Loop is a self-hosted, open-source product with a single `LOOP_API_KEY` Bearer token for authentication, the ideal pattern is:

### Option A: Auto-Generate in Setup Script (Recommended)

Add a `setup` script to `package.json` that:

1. Checks if `.env` exists
2. If not, copies `.env.example` to `.env`
3. Generates a random `LOOP_API_KEY` using `crypto.randomBytes(32).toString('hex')`
4. Writes it to `.env`
5. Prints the key prominently to the console so the developer knows what it is

```js
// scripts/setup.js
const { randomBytes } = require('crypto');
const { existsSync, writeFileSync, readFileSync } = require('fs');

const key = `loop_${randomBytes(32).toString('hex')}`;
// ...write to .env, output instructions
console.log(`
  LOOP_API_KEY generated: ${key}

  This has been written to your .env file.
  Use this key as the Bearer token for all API requests:

    Authorization: Bearer ${key}

  Keep this secret. Do not commit .env to git.
`);
```

### Option B: Interactive `npm run setup` Prompt

Use `@clack/prompts` for a richer interactive setup:

1. Welcome message
2. Ask for `DATABASE_URL` (can't be auto-generated)
3. Auto-generate `LOOP_API_KEY`, `ADMIN_JWT_SECRET`, etc.
4. Write `.env`, confirm success
5. Print next steps

This is the Strapi/Medusa pattern applied to Loop.

### Option C: Helpful Startup Error (Minimum Viable)

At minimum, improve the startup error when `LOOP_API_KEY` is missing:

```
ERROR: LOOP_API_KEY is required but not set.

Generate a key:
  node -e "console.log('loop_' + require('crypto').randomBytes(32).toString('hex'))"

Then add to .env:
  LOOP_API_KEY=loop_<your-generated-value>
```

This is the lowest-effort improvement and eliminates the "what do I put here?" confusion.

### The `.env.example` Should Be Comprehensive

```bash
# ============================================================
# Loop API Configuration
# ============================================================

# PostgreSQL connection string (Neon recommended for production)
DATABASE_URL=postgresql://user:password@localhost:5432/loop

# Bearer token for authenticating API requests
# Generate with: node -e "console.log('loop_' + require('crypto').randomBytes(32).toString('hex'))"
LOOP_API_KEY=

# ============================================================
# Webhook Secrets (only needed if using webhook ingestion)
# ============================================================

# Generate with: openssl rand -hex 32
GITHUB_WEBHOOK_SECRET=

# Generate with: openssl rand -hex 32
SENTRY_CLIENT_SECRET=

# Shared secret from PostHog webhook configuration
POSTHOG_WEBHOOK_SECRET=
```

---

## Research Gaps and Limitations

- Could not access some paywalled or rate-limited documentation pages (Postman's top-25 API onboarding list)
- Railway's specific internal API key auto-generation behavior was not definitively confirmed
- Trigger.dev's exact key generation behavior during self-hosted setup was unclear from the docs
- No data on what percentage of developers abandon self-hosted tools specifically because of the env var setup step (though anecdotal evidence suggests it is significant)

---

## Contradictions and Disputes

- **Strapi's key generation quality**: There is conflicting information about whether `create-strapi-app` generates truly random values or placeholder strings. Community evidence suggests older versions used placeholders (`toBeModified`) while newer versions generate actual random values. Production deployments should always regenerate using OpenSSL regardless.
- **"Show once" vs. "always retrievable"**: There's a genuine UX tradeoff. "Shown only once" is more secure (the hash is stored, not the raw key) but creates real friction when users lose the key and must regenerate. Some tools (Directus static tokens) make keys permanently retrievable, accepting slightly lower security for better DX.

---

## Search Methodology

- Searches performed: 18
- Most productive search terms: "create-strapi-app env auto-generated", "npx auth secret auto-generate .env", "Directus admin token first run", "Medusa npx create API key", "NextAuth npx auth secret pattern"
- Primary information sources: Official documentation (Supabase, Neon, Directus, Strapi, Medusa, Inngest, Trigger.dev, Clerk, Resend), GitHub issues, developer blogs, Treblle API onboarding research

---

## Sources

- [Understanding API Keys | Supabase Docs](https://supabase.com/docs/guides/api/api-keys)
- [Manage API Keys | Neon Docs](https://neon.com/docs/manage/api-keys)
- [API Keys | Trigger.dev](https://trigger.dev/docs/apikeys)
- [Self-Hosting | Inngest Documentation](https://www.inngest.com/docs/self-hosting)
- [Signing Keys | Inngest Documentation](https://www.inngest.com/docs/platform/signing-keys)
- [Environment Variables Configuration | Strapi 5 Documentation](https://docs.strapi.io/cms/configurations/environment)
- [Admin Panel Configuration | Strapi 5 Documentation](https://docs.strapi.io/cms/configurations/admin-panel)
- [API Tokens | Strapi 5 Documentation](https://docs.strapi.io/cms/features/api-tokens)
- [Create a Project | Directus Docs](https://docs.directus.io/self-hosted/quickstart.html)
- [Directus Admin Token Guide — Restack](https://www.restack.io/docs/directus-knowledge-directus-admin-token-guide)
- [API Key Module | Medusa Documentation](https://docs.medusajs.com/resources/commerce-modules/api-key)
- [Options | NextAuth.js](https://next-auth.js.org/configuration/options)
- [Auth.js Environment Variables](https://authjs.dev/guides/environment-variables)
- [Create API Key | Resend](https://resend.com/docs/api-reference/api-keys/create-api-key)
- [Introduction | Resend Dashboard](https://resend.com/docs/dashboard/api-keys/introduction)
- [Using API Keys - Machine Authentication | Clerk Docs](https://clerk.com/docs/guides/development/machine-auth/api-keys)
- [Add API Key Support to Your SaaS | Clerk Blog](https://clerk.com/blog/add-api-key-support-to-your-saas-with-clerk)
- [Unkey - Developer Platform for Modern APIs](https://www.unkey.com/)
- [GitHub - unkeyed/unkey](https://github.com/unkeyed/unkey)
- [Building an NPX Script for Project Setup | GetStream](https://getstream.io/blog/npx-script-project-setup/)
- [API Integration Best Practices | Treblle](https://treblle.com/blog/accelerating-api-integrations-best-practices-for-faster-onboarding)
- [How would I create my own APP_KEYS, ADMIN_JWT_SECRET? | Strapi GitHub Issue](https://github.com/strapi/strapi/issues/15206)
- [RFC: Autogenerate NEXTAUTH_SECRET | next-auth GitHub Issue #4499](https://github.com/nextauthjs/next-auth/issues/4499)
- [Manage Secret API Keys in Medusa Admin](https://docs.medusajs.com/user-guide/settings/developer/secret-api-keys)
- [Ghost Admin API Credentials | n8n Community](https://community.n8n.io/t/ghost-admin-api-credentials/52432)
- [A Guide to Storing API Keys Securely with Environment Variables | Netlify](https://www.netlify.com/blog/a-guide-to-storing-api-keys-securely-with-environment-variables/)
- [CLI | Better Auth](https://www.better-auth.com/docs/concepts/cli)
- [API Onboarding: Strategies for Smooth Integration Success | Tyk](https://tyk.io/blog/api-onboarding-strategies-for-smooth-integration-success/)
